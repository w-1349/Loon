#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import re
import time
import ipaddress
from datetime import datetime, timedelta
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# ================= é…ç½®åŒº =================
RULE_SOURCES = [
    {"name": "AdRules", "url": "https://raw.githubusercontent.com/Cats-Team/AdRules/main/adrules.list"},
    {"name": "anti-ad", "url": "https://anti-ad.net/surge2.txt"},
    {"name": "ADG", "url": "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Advertising/Advertising.list"},
    {"name": "ADG_Domain", "url": "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Advertising/Advertising_Domain.list"},
    {"name": "Privacy", "url": "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Privacy/Privacy.list"},
    {"name": "Privacy_Domain", "url": "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Loon/Privacy/Privacy_Domain.list"},
]

OUTPUT_FILE = "Loon_rules.txt"
REMOVED_LOG_FILE = "loon_rules.log"
SUBSCRIBE_URL = "https://ddcm1349.github.io/Loon/Loon_rules.txt"

# ä¸¥è°¨å±é™©è¯åº“ï¼šä»…å½“è§„åˆ™ã€å®Œå…¨ç­‰äºã€‘è¿™äº›è¯æ—¶è§¦å‘æ‹¦æˆª
# åŒ…å«é¡¶çº§åŸŸå (TLD) ä¸å¸¸è§çš„å›½å®¶/åœ°åŒºçº§äºŒåç¼€ (SLD)
INVALID_KEYWORDS = {
    'com', 'net', 'cn', 'org', 'io', 'co', 'tv', 'cc', 'app', 'dev', 'top', 'xyz', 'info',
    'com.cn', 'net.cn', 'org.cn', 'gov.cn', 'edu.cn', 'ac.cn',
    'com.hk', 'net.hk', 'org.hk', 'com.tw', 'net.tw', 'org.tw',
    'com.sg', 'com.jp', 'co.uk', 'org.uk', 'com.au', 'com.mo'
}
# ==========================================

def get_beijing_time():
    """è·å–å½“å‰æ ¼å¼åŒ–çš„åŒ—äº¬æ—¶é—´"""
    return (datetime.utcnow() + timedelta(hours=8)).strftime('%Y-%m-%d %H:%M:%S')

def log(msg, level="INFO"):
    """çŠ¶æ€æ—¥å¿—æ‰“å°"""
    timestamp = get_beijing_time()
    prefix = {"INFO": "â„¹ï¸", "OK": "âœ…", "ERROR": "âŒ"}.get(level, "â€¢")
    print(f"[{timestamp}] {prefix} {msg}", flush=True)

def create_session():
    """å»ºç«‹å¸¦è‡ªåŠ¨é‡è¯•æœºåˆ¶çš„ HTTP ä¼šè¯"""
    session = requests.Session()
    retries = Retry(total=3, backoff_factor=1, status_forcelist=[500, 502, 503, 504])
    session.mount("http://", HTTPAdapter(max_retries=retries))
    session.mount("https://", HTTPAdapter(max_retries=retries))
    session.headers.update({"User-Agent": "Mozilla/5.0 LoonRuleEngine/3.5"})
    return session

def is_valid_domain(domain):
    """éªŒè¯åŸŸåæ ¼å¼ï¼ŒåŒºåˆ† IP å’Œæ ‡å‡†åŸŸå"""
    if not domain or len(domain) > 253: return False
    if re.match(r'^(\d{1,3}\.){3}\d{1,3}$', domain): return True
    if not re.match(r'^[a-z0-9\-\.]+$', domain): return False
    labels = domain.split('.')
    return len(labels) >= 2 and not labels[-1].isdigit()

def is_dangerous_rule(rval):
    """
    å…¨ç­‰åŒ¹é…åˆ¤å®šã€‚
    é˜²æ­¢å±è”½æ•´ä¸ª com.cn æˆ– cn ç­‰åç¼€å¯¼è‡´çš„å¤§è§„æ¨¡è®¿é—®æ•…éšœã€‚
    """
    return rval.lower() in INVALID_KEYWORDS

def parse_loon_rule(line):
    """è§£æ Loon åŸå§‹è§„åˆ™è¡Œ"""
    parts = line.split(',')
    if len(parts) < 2: return None
    params = [p.strip().lower() for p in parts[2:] if p.strip()]
    return (parts[0].strip().upper(), parts[1].strip(), params)

def normalize_rule_smart(rtype, rval, rparams):
    """æ ‡å‡†åŒ–è§„åˆ™æ ¼å¼"""
    rval = rval.lower()
    if rtype in ("DOMAIN", "DOMAIN-SUFFIX", "DOMAIN-KEYWORD"):
        return f"{rtype},{rval}"
    if rtype in ("IP-CIDR", "IP-CIDR6"):
        return f"{rtype},{rval},no-resolve" if "no-resolve" in rparams else f"{rtype},{rval}"
    return f"{rtype},{rval}"

def is_covered_by_trie(val, trie):
    """ä½¿ç”¨å­—å…¸æ ‘å¿«é€Ÿåˆ¤å®šåç¼€åŒ…å«å…³ç³»"""
    node = trie
    for part in val.split('.')[::-1]:
        if part not in node: return False
        node = node[part]
        if "#" in node: return True
    return False

def dedup_engine(rules):
    """
    æ·±åº¦ç²¾ç®€å¼•æ“ã€‚
    é€»è¾‘ï¼šå»é‡ç›¸åŒè§„åˆ™ -> å±é™©åˆ¤å®š -> åç¼€åŒ…å«åˆ¤å®š -> CIDR ç½‘æ®µåˆ¤å®š
    """
    stats = {'danger': 0, 'logic': 0, 'exact': 0}
    seen = set()
    unique_base = []
    log_logic = []

    # 1. ç‰©ç†å±‚å»é‡ï¼ˆè·¨æºå®Œå…¨é‡å¤é¡¹ï¼‰
    for r in rules:
        p = parse_loon_rule(r)
        if not p: continue
        norm = normalize_rule_smart(*p)
        if norm not in seen:
            seen.add(norm)
            unique_base.append(p)
        else: 
            stats['exact'] += 1

    key_rules, suf_raw, dom_raw, ip_raw, ip6_rules = [], [], [], [], []

    # 2. å±é™©æ‹¦æˆªä¸è§„åˆ™åˆ†ç±»
    for rtype, rval, rparams in unique_base:
        raw_str = normalize_rule_smart(rtype, rval, rparams)
        
        if is_dangerous_rule(rval):
            stats['danger'] += 1
            log_logic.append(f"[å±é™©æ‹¦æˆª] {raw_str} (å› è¯•å›¾å±è”½åŸºç¡€åŸŸååç¼€å·²è¢«å‰”é™¤)")
            continue

        if rtype == 'DOMAIN-KEYWORD':
            key_rules.append(raw_str)
        elif rtype == 'DOMAIN-SUFFIX':
            suf_raw.append((raw_str, rval))
        elif rtype == 'DOMAIN':
            dom_raw.append((raw_str, rval))
        elif rtype == 'IP-CIDR':
            try:
                net = ipaddress.IPv4Network(rval, strict=False)
                ip_raw.append((raw_str, net))
            except: continue
        elif rtype == 'IP-CIDR6':
            ip6_rules.append(raw_str)

    # 3. DOMAIN-SUFFIX å†…éƒ¨åŒ…å«åˆ¤å®š (Trie ç®—æ³•)
    suf_raw.sort(key=lambda x: len(x[1].split('.')))
    trie, final_suf = {}, []
    for rule_str, val in suf_raw:
        if not is_covered_by_trie(val, trie):
            final_suf.append(rule_str)
            node = trie
            for part in val.split('.')[::-1]: node = node.setdefault(part, {})
            node["#"] = True
        else: 
            stats['logic'] += 1
            log_logic.append(f"[é€»è¾‘è¦†ç›–] {rule_str:<45} # è¢«æ›´çŸ­çš„åç¼€æ¶µç›–")

    # 4. DOMAIN ç±»å‹è¢«åç¼€æ¶µç›–åˆ¤å®š
    final_dom = []
    for r, v in dom_raw:
        if is_covered_by_trie(v, trie): 
            stats['logic'] += 1
            log_logic.append(f"[é€»è¾‘è¦†ç›–] {r:<45} # å·²è¢«åç¼€è§„åˆ™åŒ…å«")
        else: 
            final_dom.append(r)

    # 5. IP-CIDR ç½‘æ®µè¦†ç›–åˆ¤å®š
    ip_raw.sort(key=lambda x: x[1].prefixlen)
    kept_ip_nets, final_ip = [], []
    for rule_str, net in ip_raw:
        is_covered = False
        for k_net in kept_ip_nets:
            if k_net.supernet_of(net):
                is_covered = True
                log_logic.append(f"[é€»è¾‘è¦†ç›–] {rule_str:<45} # è¢«å¤§ç½‘æ®µ {k_net} åŒ…å«")
                break
        if not is_covered:
            final_ip.append(rule_str)
            kept_ip_nets.append(net)
        else: 
            stats['logic'] += 1

    # 6. çº¯ IP è·¨ç±»è¦†ç›–é€»è¾‘åˆ¤å®š
    final_dom_clean = []
    for r_str in final_dom:
        v = r_str.split(',')[1]
        if re.match(r'^(\d{1,3}\.){3}\d{1,3}$', v):
            try:
                ip_obj = ipaddress.IPv4Address(v)
                if any(ip_obj in k_net for k_net in kept_ip_nets):
                    stats['logic'] += 1
                    log_logic.append(f"[é€»è¾‘è¦†ç›–] {r_str:<45} # è¯¥ IP å·²åœ¨ç½‘æ®µè§„åˆ™ä¸­")
                    continue
            except: pass
        final_dom_clean.append(r_str)

    res = final_dom_clean + final_suf + key_rules + final_ip + ip6_rules
    return res, stats, log_logic

def format_source_stats(source_stats):
    """æ ¼å¼åŒ–ç»Ÿè®¡è¡¨æ ¼"""
    max_name_len = max(len(s['name']) for s in source_stats)
    width = max(max_name_len, 10)
    lines = ["# " + "=" * (width + 25)]
    lines.append(f"# {'åç§°':<{width}} {'åŸå§‹':>8} {'æœ‰æ•ˆ':>8} {'ç‰©ç†å»é‡':>8}")
    lines.append("# " + "-" * (width + 25))
    for s in source_stats:
        lines.append(f"# {s['name']:<{width}} {s['raw']:>8} {s['valid']:>8} {s['raw']-s['valid']:>8}")
    lines.append("# " + "=" * (width + 25))
    return lines

def main():
    log("ğŸš€ å¯åŠ¨è§„åˆ™åˆå¹¶ä»»åŠ¡ (SLD é˜²æŠ¤å¢å¼ºç‰ˆ)...", "INFO")
    session, all_rules, source_stats = create_session(), [], []
    total_start = time.time()

    # æ•°æ®åŒæ­¥é˜¶æ®µ
    for idx, src in enumerate(RULE_SOURCES, 1):
        log(f"[{idx}/{len(RULE_SOURCES)}] åŒæ­¥ä¸­: {src['name']}")
        try:
            resp = session.get(src['url'], timeout=20)
            resp.raise_for_status()
            raw_lines = resp.text.splitlines()
            processed = []
            for l in raw_lines:
                l = l.strip()
                if not l or any(l.startswith(x) for x in ('#', '!', '[')): continue
                if re.match(r'^(\d{1,3}\.){3}\d{1,3}/\d{1,2}$', l): processed.append(f"IP-CIDR,{l}")
                elif re.match(r'^(\d{1,3}\.){3}\d{1,3}$', l): processed.append(f"DOMAIN,{l}")
                elif l.startswith('.'): processed.append(f"DOMAIN-SUFFIX,{l[1:]}")
                elif ',' not in l and is_valid_domain(l): processed.append(f"DOMAIN,{l}")
                else: processed.append(l)
            all_rules.extend(processed)
            source_stats.append({"name": src['name'], "raw": len(raw_lines), "valid": len(processed)})
        except Exception as e:
            log(f"åŒæ­¥å¤±è´¥: {src['name']} ({e})", "ERROR")

    # é€»è¾‘åˆ†æé˜¶æ®µ
    log("æ­£åœ¨åˆ†æå»é‡é€»è¾‘å¹¶åº”ç”¨ SLD é˜²æŠ¤...", "INFO")
    final_list, stats, log_logic = dedup_engine(all_rules)
    
    # ç»“æœæ’åº (DOMAIN > SUFFIX > KEYWORD > IP)
    prio = {'DOMAIN': 1, 'DOMAIN-SUFFIX': 2, 'DOMAIN-KEYWORD': 3, 'IP-CIDR': 4, 'IP-CIDR6': 5}
    final_list.sort(key=lambda x: (prio.get(x.split(',')[0], 99), x.lower()))

    # æ–‡ä»¶å¤´æ„å»º
    header = [
        f"# Loon åˆºå®¢åˆé›† (ä¸¥è°¨ç²¾ç®€ç‰ˆ)",
        f"# ç”Ÿæˆæ—¶é—´: {get_beijing_time()}",
        f"# å‹ç¼©ä¼˜åŒ–: å±é™©æ‹¦æˆª {stats['danger']} | é€»è¾‘å»é‡ {stats['logic']} | è·¨æºç‰©ç†å»é‡ {stats['exact']}",
        f"# è®¢é˜…åœ°å€: {SUBSCRIBE_URL}",
    ]
    header.extend(format_source_stats(source_stats))
    
    # è¾“å‡ºç»“æœ
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write('\n'.join(header) + '\n\n' + '\n'.join(final_list))
    
    # è¾“å‡ºæ—¥å¿—
    with open(REMOVED_LOG_FILE, 'w', encoding='utf-8') as f:
        f.write(f"# Loon è¿‡æ»¤æ—¥å¿— - {get_beijing_time()}\n")
        f.write(f"# ----------------------------------------------------------\n")
        f.write(f"# é€»è¾‘ç²¾ç®€æ€»æ•°: {len(log_logic)} æ¡\n")
        f.write(f"# ç‰©ç†é‡å¤æ€»æ•°: {stats['exact']} æ¡\n")
        f.write(f"# ----------------------------------------------------------\n\n")
        f.write('\n'.join(log_logic) if log_logic else "æœ¬æ¬¡æœªå‘ç°é€»è¾‘å†²çªé¡¹ã€‚")

    log(f"âœ… å¤„ç†å®Œæˆï¼ä¿ç•™è§„åˆ™ {len(final_list)} æ¡ | è€—æ—¶: {time.time()-total_start:.1f}s", "OK")

if __name__ == "__main__":
    main()
